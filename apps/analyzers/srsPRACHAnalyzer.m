%srsPRACHAnalyzer Analyzes a PRACH transmission from a PRACH resource grid.
%   srsPRACHAnalyzer(PRACH, FILENAME, OFFSET, SIZE) analyzes an NR Preamble for
%   Random Access Channel transmission. PRACH is an object of type
%   nrPRACHConfig containing the paramaters necessary for the detection.
%   FILENAME indicates the file that contains the IQ samples. OFFSET and SIZE are
%   the offset and the size, as a number of single-precision complex floating point numbers,
%   of the desired PRACH occasion inside the file.
%
%   The relevant data can be found in the log file generated by the srsRAN gNB:
%   look for lines like the following
%   2023-02-14T22:29:05.801598 [Upper PHY] [I] [   273.4] RX_PRACH: sector=0 offset=1391191 size=3336
%
%   Example:
%      prach = nrPRACHConfig;
%      prach.DuplexMode = 'TDD';
%      prach.ConfigurationIndex = 159;
%      prach.SubcarrierSpacing = 30;
%      prach.LRA = 139;
%      prach.SequenceIndex = 1;
%      prach.PreambleIndex = 48;
%
%      srsPRACHAnalyzer(prach, '~/Downloads/ul_symbol_handler', 1391191, 3336);
%
%   Remark: The nrPRACHConfig object can also be created from the logs with the
%   srsParseLogs helper function.

%   Copyright 2021-2025 Software Radio Systems Limited
%
%   This file is part of srsRAN-matlab.
%
%   srsRAN-matlab is free software: you can redistribute it and/or
%   modify it under the terms of the BSD 2-Clause License.
%
%   srsRAN-matlab is distributed in the hope that it will be useful,
%   but WITHOUT ANY WARRANTY; without even the implied warranty of
%   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
%   BSD 2-Clause License for more details.
%
%   A copy of the BSD 2-Clause License can be found in the LICENSE
%   file in the top-level directory of this distribution.

function srsPRACHAnalyzer(prach, filename, offset, prachSize)
    import srsTest.helpers.readComplexFloatFile

    nPorts = floor(prachSize / prach.LRA / prach.PRACHDuration);

    assert(prachSize == prach.LRA * prach.PRACHDuration * nPorts, ['The buffer size %d ', ...
        'is not consistend with a PRACH with %d replicas of %d ZC symbols.'], prachSize, prach.PRACHDuration, prach.LRA);

    samples = reshape(readComplexFloatFile(filename, offset, prachSize), [prach.LRA, prach.PRACHDuration, nPorts]);

    % Set active PRACH slot (just in case the user didn't set it).
    if (prach.SubcarrierSpacing == 30)
        prach.ActivePRACHSlot = 1;
    else
        prach.ActivePRACHSlot = 0;
    end

    % Create carrier which is not relevant for the analysis.
    carrier = nrCarrierConfig;

    % Generate PRACH symbols.
    symbols = [];
    while isempty(symbols)
        symbols = nrPRACH(carrier, prach);
        prach.NPRACHSlot = prach.NPRACHSlot + 1;
    end

    assert(length(symbols) == numel(samples(:,:,1)), ['The given PRACH configuration is not ', ...
        'compatible with the buffer size.']);

    symbols = reshape(symbols, [prach.LRA, prach.PRACHDuration]);

    figFrequencyPower = figure("Name", "srsPRACHAnalyzer: Frequency domain sequence power");
    tiledlayout('flow');
    figFrequencyPhase = figure("Name", "srsPRACHAnalyzer: Frequency domain correlation phase");
    tiledlayout('flow');
    figTime = figure("Name", "srsPRACHAnalyzer: Time domain correlation");
    tiledlayout('flow');

    for iPort = 1:nPorts
        % Perform correlation in frequency domain.
        corrFreq = samples(:, :, iPort) ./ symbols;

        % Select a DFT size that matches the TA timing resolution.
        dftSize = 1920 / prach.SubcarrierSpacing;

        corrTime = fftshift(ifft(corrFreq, dftSize, 1));

        AbsCorrTime = corrTime .* conj(corrTime);
        [~, MaxCorrTimeIndex] = max(AbsCorrTime);

        samplingRateMHz = dftSize * prach.SubcarrierSpacing * 1e-3;
        timeAxisMicros = (0:(dftSize -1)) / samplingRateMHz - dftSize / samplingRateMHz / 2;

        % Plot PRACH frequency response magnitude.
        figure(figFrequencyPower);
        nexttile
        plot(20 * log10(abs(samples(:, :, iPort))));
        xlabel('PRACH Subcarrier index');
        ylabel('Relative power [dB]');
        grid on;

        % Plot PRACH correlation frequency response phase.
        figure(figFrequencyPhase);
        nexttile
        plot(angle(corrFreq) * 180 / pi);
        xlabel('PRACH Subcarrier index');
        ylabel('Angle (deg)');
        grid on;

        % Plot PRACH correlation in time.
        figure(figTime);
        nexttile
        hPlot = plot(timeAxisMicros, AbsCorrTime);
        xlabel('Time aligment from window [microseconds]');
        ylabel('Linear power');
        grid on;

        for iReplica = 1:prach.PRACHDuration
            datatip(hPlot(iReplica), timeAxisMicros(MaxCorrTimeIndex(iReplica)), AbsCorrTime(MaxCorrTimeIndex(iReplica), iReplica));
        end
    end

end
