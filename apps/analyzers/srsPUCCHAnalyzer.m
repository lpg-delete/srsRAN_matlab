%srsPUCCHAnalyzer Analyzes a PUCCH transmission from a resource grid.
%   srsPUCCHAnalyzer(CARRIER, PUCCH, RGFILENAME, RGOFFSET, RGSIZE) analyzes the
%   NR Physical Uplink Control Channel transmission detailed by the carrier
%   configuration CARRIER and by the control channel configuration PUCCH (either
%   Format 1 or Format 2). The resource grid IQ samples are stored in the
%   binary file RGFILENAME. RGOFFSET and RGSIZE are the offset and size, as
%   a number of single-precision complex floating point numbers, of the slot
%   containing the PUCCH transmission inside the binary file.
%
%   Example:
%   % The relevant data can be found in the log file generated by the srsRAN gNB:
%   % look for lines like the following
%   %    2023-06-07T20:54:24.502414 [Upper PHY] [I] [  584.19] RX_SYMBOL: sector=0 offset=636504 size=45864
%   %    2023-06-07T20:54:24.502277 [UL-PHY2 ] [D] [  584.19] PUCCH: rnti=0x4601 format=1 ...
%
%   % Use srsParseLogs to populate the carrier and PUCCH configuration objects
%   % (you will be asked to select the PUCCH entry of the logs):
%   [carrier, pucch] = srsParseLogs
%
%   % Launch the analyzer
%   srsPUCCHAnalyzer(carrier, pucch, 'rx_symbols.bin', 636504, 45864)
%
%   See also srsParseLogs.

%   Copyright 2021-2025 Software Radio Systems Limited
%
%   This file is part of srsRAN-matlab.
%
%   srsRAN-matlab is free software: you can redistribute it and/or
%   modify it under the terms of the BSD 2-Clause License.
%
%   srsRAN-matlab is distributed in the hope that it will be useful,
%   but WITHOUT ANY WARRANTY; without even the implied warranty of
%   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
%   BSD 2-Clause License for more details.
%
%   A copy of the BSD 2-Clause License can be found in the LICENSE
%   file in the top-level directory of this distribution.

function srsPUCCHAnalyzer(carrier, pucch, rgFilename, rgOffset, rgSize)
    arguments
        carrier    (1, 1) nrCarrierConfig
        pucch      (1, 1) {mustBeA(pucch, ["nrPUCCH1Config", "nrPUCCH2Config", "nrPUCCH3Config", "nrPUCCH4Config"])}
        rgFilename (1, :) char {mustBeFile}
        rgOffset   (1, 1) double {mustBeInteger, mustBePositive}
        rgSize     (1, 1) double {mustBeInteger, mustBePositive}
    end

    nSubcarriers = carrier.NSizeGrid * 12;
    nSymbols = 14;
    nPorts = floor(rgSize / (nSubcarriers * nSymbols));

    assert(nSubcarriers * nSymbols * nPorts == rgSize, ['The dimensions of the resource grid ', ...
        '(%d x %d) are not consistent with the buffer size %d.'], nSubcarriers, nSymbols, rgSize);

    % Read file containing the resource grid.
    rxGrid = reshape(srsTest.helpers.readComplexFloatFile(rgFilename, rgOffset, rgSize), ...
        [nSubcarriers, nSymbols, nPorts]);

    dmrsInd = nrPUCCHDMRSIndices(carrier, pucch);
    dmrsSym = nrPUCCHDMRS(carrier, pucch);

    [estChannel, noiseEst] = nrChannelEstimate(carrier, rxGrid, dmrsInd, dmrsSym);

    % Get PUCCH REs from received grid and estimated channel grid.
    pucchIndices = nrPUCCHIndices(carrier, pucch);
    [pucchRx, pucchHest] = nrExtractResources(pucchIndices, rxGrid, estChannel);

    % Perform equalization.
    pucchEq = nrEqualizeMMSE(pucchRx, pucchHest, noiseEst);

    % % Decode PUCCH symbols
    % % TODO: For this, we need to log the number of uncoded UCI bits, which is not
    % %       done at the moment.
    % [uciLLRs, rxSymbols] = nrPUCCHDecode(carrier, pucch, ouci, pucchEq, noiseEst);

    figRG = figure("Name", "srsPUCCHAnalyzer: Resource grid amplitude");
    tiledlayout(nPorts, 1);
    figChannel = figure("Name", "srsPUCCHAnalyzer: Channel estimate");
    tiledlayout(nPorts, 2);

    for iPort=1:nPorts
        % Plot resource grid power.
        figure(figRG)
        nexttile
        imagesc(0, 0, abs(rxGrid(:, :, iPort)));
        % By default, imagesc reverses the y axis.
        set(gca, 'YDir','normal');
        colorbar;
        xlabel('Symbol')
        ylabel('Subcarrier')

        % Plot estimated channel magnitude.
        figure(figChannel)
        nexttile
        [symbolIndices, subcIndices] = meshgrid(0:nSymbols - 1, 0:nSubcarriers - 1);
        surf(symbolIndices, subcIndices, abs(estChannel(:, :, iPort)), 'LineStyle','none', 'FaceColor','flat');
        shading flat;
        colorbar;
        xlabel('Symbol');
        ylabel('Subcarrier');
        zlabel('Magnitude');
        zmin = min(abs(estChannel(:,:,iPort)), [], 'all') * 0.9;
        zmax = max(abs(estChannel(:,:,iPort)), [], 'all') * 1.1;
        if zmin == zmax
            zmin = zmin - 0.5;
            zmax = zmax + 0.5;
        end
        axis([0, nSymbols - 1, 0, nSubcarriers - 1, zmin, zmax]);

        % Plot estimated channel phase.
        nexttile
        surf(symbolIndices, subcIndices, angle(estChannel(:, :, iPort)), 'LineStyle','none', 'FaceColor','flat');
        shading flat;
        colorbar;
        xlabel('Symbol');
        ylabel('Subcarrier');
        zlabel('Angle [rad]');
        zmin = min(angle(estChannel(:,:,iPort)), [], 'all') * 0.9;
        zmax = max(angle(estChannel(:,:,iPort)), [], 'all') * 1.1;
        if zmin == zmax
            zmin = zmin - 0.5;
            zmax = zmax + 0.5;
        end
        axis([0, nSymbols - 1, 0, nSubcarriers - 1, zmin, zmax]);
    end

    figure
    % Plot detected constellation.
    plot(real(pucchEq), imag(pucchEq), 'x');
    grid on;
    xlabel('Real');
    ylabel('Imaginary');
    title('srsPUCCHAnalyzer: Equalized constellation');
    axis([-1.2, 1.2, -1.2, 1.2])

    % % Plot soft bits histogram.
    % subplot(NumYPlots, NumXPlots, 5);
    % histogram(uciLLRs, 'Normalization', 'pdf');
    % grid on;
    % xlabel('Soft bits');
    % ylabel('Soft bit count');
    % title('Received soft bit distribution');
