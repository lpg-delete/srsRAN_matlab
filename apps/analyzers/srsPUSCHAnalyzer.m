%srsPUSCHAnalyzer Analyzes a PUSCH transmission from a resource grid.
%   srsPUSCHAnalyzer(CARRIER, PUSCH, EXTRA, RGFILENAME, RGOFFSET, RGSIZE) analyzes the
%   NR Physical Uplink Shared Channel transmission detailed by the carrier
%   configuration CARRIER, by the shared channel configuration PUSCH and by the
%   content of the EXTRA struct (with fields RV (redundancy version), TargetCodeRate
%   and TransportBlockLength). The resource grid IQ samples are stored in the
%   binary file RGFILENAME. RGOFFSET and RGSIZE are the offset and size, as
%   a number of single-precision complex floating point numbers, of the slot
%   containing the PUSCH transmission inside the binary file.
%
%   Example:
%   % The relevant data can be found in the log file generated by the srsRAN gNB:
%   % look for lines like the following
%   %    2023-02-14T22:29:05.651121 [Upper PHY] [I] [   258.4] RX_SYMBOL: sector=0 offset=1141879 size=17808
%   %    2023-02-14T22:29:05.651257 [UL-PHY1 ] [D] [   258.4] PUSCH: harq_id=0 rnti=0x4601 ...
%
%   % Use srsParseLogs to populate the carrier and PUSCH configuration objects, as
%   % well as the EXTRA struct (you will be asked to select the PUSCH entry of the logs):
%   [carrier, pusch, extra] = srsParseLogs
%
%   % Launch the analyzer
%   srsPUSCHAnalyzer(carrier, pusch, extra, 'rx_symbols.bin', 1141879, 17808)
%
%   See also srsParseLogs.

%   Copyright 2021-2025 Software Radio Systems Limited
%
%   This file is part of srsRAN-matlab.
%
%   srsRAN-matlab is free software: you can redistribute it and/or
%   modify it under the terms of the BSD 2-Clause License.
%
%   srsRAN-matlab is distributed in the hope that it will be useful,
%   but WITHOUT ANY WARRANTY; without even the implied warranty of
%   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
%   BSD 2-Clause License for more details.
%
%   A copy of the BSD 2-Clause License can be found in the LICENSE
%   file in the top-level directory of this distribution.

function srsPUSCHAnalyzer(carrier, pusch, extra, rgFilename, rgOffset, rgSize)
    arguments
        carrier    (1, 1) nrCarrierConfig
        pusch      (1, 1) nrPUSCHConfig
        extra      (1, 1) struct
        rgFilename (1, :) char {mustBeFile}
        rgOffset   (1, 1) double {mustBeInteger, mustBeNonnegative}
        rgSize     (1, 1) double {mustBeInteger, mustBePositive}
    end

%% Imprt dependencies.
import srsTest.helpers.readComplexFloatFile

%% Prepare configuration.

% Other parameters.
multipleHARQProcesses = false;
targetCodeRate = extra.TargetCodeRate;
rv = extra.RV;
transportBlockLength = extra.TransportBlockLength;

%% Load resource grid.
nSubcarriers = carrier.NSizeGrid * 12;
nSymbols = 14;
nPorts = floor(rgSize / (nSubcarriers * nSymbols));

assert(nSubcarriers * nSymbols * nPorts == rgSize, ['The dimensions of the resource grid ', ...
    '(%d x %d) are not consistent with the buffer size %d.'], nSubcarriers, nSymbols, rgSize);

% Read file containing the resource grid.
rxGrid = reshape(readComplexFloatFile(rgFilename, rgOffset, rgSize), ...
    [nSubcarriers, nSymbols, nPorts]);

%% Estimate channel.

dmrsInd = nrPUSCHDMRSIndices(carrier, pusch);
dmrsSym = nrPUSCHDMRS(carrier, pusch);

[H, nVar, ~] = nrChannelEstimate(carrier, rxGrid, dmrsInd, dmrsSym);

if pusch.DMRS.NumCDMGroupsWithoutData
    H = H * sqrt(1 / 2);
end

% Remove DC from the grid if it is available.
if ~isempty(extra.dcPosition)
    rxGrid(extra.dcPosition + 1, :) = 0;
end

%% Equalize.
[dataInd, puschInfo] = nrPUSCHIndices(carrier, pusch);

[rxSym, Hest] = nrExtractResources(dataInd, rxGrid, H);

[equalized, ~] = nrEqualizeMMSE(rxSym, Hest, nVar);

%% Decode.
% Make sure the TBS is consistent.
transportBlockLength2 = nrTBS(pusch.Modulation, pusch.NumLayers, length(pusch.PRBSet), puschInfo.NREPerPRB, targetCodeRate);
if transportBlockLength ~= transportBlockLength2
    error('Incosistent configuration: the computed TBS is %d, the provided one is %d.', ...
        transportBlockLength2, transportBlockLength);
end

% Demodulate codeword.
[rxcw, ~] = nrPUSCHDecode(carrier, pusch, equalized, nVar);

% Make sure equalized zeros translate to soft zeros.
zerosInd = (equalized == 0);
cwZerosInd = repelem(zerosInd, 6);
rxcw(cwZerosInd) = 0;

% Prepare UL-SCH decoder.
ULSCHDecoder = nrULSCHDecoder( ...
    MultipleHARQProcesses=multipleHARQProcesses, ...
    TargetCodeRate=targetCodeRate, ...
    TransportBlockLength=transportBlockLength ...
    );

% Decode.
[~, blkCRCErr] = ULSCHDecoder(rxcw, pusch.Modulation, pusch.NumLayers, rv);

crcStatus = 'OK';
if (blkCRCErr == 1)
    crcStatus = 'KO';
end
fprintf('The block CRC is %s.\n', crcStatus);

%% Plot analysis.
figRG = figure("Name", "srsPUSCHAnalyzer: Resource grid amplitude");
tiledlayout(nPorts, 1);
figChannel = figure("Name", "srsPUSCHAnalyzer: Channel estimate");
tiledlayout(nPorts, 2);

for iPort=1:nPorts
    % Plot resource grid power.
    figure(figRG);
    nexttile
    imagesc(0, 0, abs(rxGrid(:,:,iPort)));
    % By default, imagesc reverses the y axis.
    set(gca, 'YDir','normal');
    colorbar;
    xlabel('Symbol');
    ylabel('Subcarrier');

    % Plot estimated channel magnitude.
    figure(figChannel);
    nexttile
    subcIndexes = 0:nSubcarriers - 1;
    symbolIndexes = 0:nSymbols - 1;
    [symbolIndexes, subcIndexes] = meshgrid(symbolIndexes, subcIndexes);
    surf(symbolIndexes, subcIndexes, abs(H(:,:,iPort)), 'LineStyle','none', 'FaceColor','flat');
    shading flat;
    colorbar;
    xlabel('Symbol');
    ylabel('Subcarrier');
    zlabel('Magnitude');
    zmin = min(abs(H(:,:,iPort)), [], 'all') * 0.9;
    zmax = max(abs(H(:,:,iPort)), [], 'all') * 1.1;
    if zmin == zmax
        zmin = zmin - 0.5;
        zmax = zmax + 0.5;
    end
    axis([0, nSymbols - 1, 0, nSubcarriers - 1, zmin, zmax]);

    % Plot estimated channel phase.
    nexttile
    surf(symbolIndexes, subcIndexes, angle(H(:,:,iPort)), 'LineStyle','none', 'FaceColor','flat');
    shading flat;
    colorbar;
    xlabel('Symbol');
    ylabel('Subcarrier');
    zlabel('Angle [rad]');
    zmin = min(angle(H(:,:,iPort)), [], 'all') * 0.9;
    zmax = max(angle(H(:,:,iPort)), [], 'all') * 1.1;
    if zmin == zmax
        zmin = zmin - 0.5;
        zmax = zmax + 0.5;
    end
    axis([0, nSymbols - 1, 0, nSubcarriers - 1, zmin, zmax]);
end

figure("Name", "srsPUSCHAnalyzer")
tiledlayout('flow')
% Plot detected constellation.
nexttile
plot(real(equalized), imag(equalized), 'x');
grid on;
xlabel('Real');
ylabel('Imaginary');
title('Equalized constellation');

% Plot soft bits histogram.
nexttile
histogram(rxcw, 'Normalization', 'pdf');
grid on;
xlabel('Soft bits');
ylabel('Soft bit count');
title('Received soft bit distribution');

end % srsPUSCHAnalyzer
